# 快速排序和线性排序 #
## 介绍 ##
	快速排序是一种划分交换排序，采用的是分治策略。一次排序将数据分割成两个部分，一部分比基准小，一部分比基准大。
	可见，其关键就是关于基准元素的选取以及划分算法的设计。
	快速排序是基于比较的排序，无法突破O(nlogn)的时间界限，但线性排序是不基于比较的排序，可以突破这一界限。
	不过线性排序的使用范围有很多限制，例如数据量的大小，排序数据的范围等。
	
	本文包括快速排序的四个优化和线性排序（计数排序、桶排序和基数排序）的实现。
	快速排序的一大特点就是效率不稳定，运行时间与输入的数据密切相关。
	因此，采用十万个随机数据，正序数据、逆序数据以及完全重复数据作为测试用例比较快速排序的几个优化和三种线性排序的效率。

## 快速排序的几个优化 ##
    快速排序的最初实现是选取左端点为基准，进行双向扫描(quicksort_1)。
    以下为四个针对不同方面进行的优化：
    1. (quicksort_2)随机选取基准，仍然进行双向扫描
    2. (quicksort_3)随机选取基准，仍然双向扫描，但当排序范围缩小到一定程度时，采取插入排序
    3. (quicksort_4)改进的三数取中法选取基准，仍然双向扫描，当排序范围缩小到一定程度时，采取插入排序
    4. (quicksort_eeee)改进的三数取中法选取基准，三路划分算法，当排序范围缩小到一定程度时，采取插入排序

### 优化1 随机选取基准 ###
    最理想的基准值能把数组分成相当的两部分。
    对于随机的输入数据，固定的选取数组最左端元素和其他选取方法是一样的，在平均情况下二者都会接近中间的位置。
    但当输入数据本身有序时，随机选取数组中某个位置上的元素而不总是选取最左端元素可以有效避免快排退化为O(n^2)。
    
    随机选取基准函数如下：
```c
int rand(int l, int r){
	srand((unsigned)time(NULL));
	int size = r - l + 1;
	return l + rand() % size;
}
```
    然后通过 "swap(&ar[l], &ar[m]);" 将选取的基准移到最左端，其余部分与最初实现一样。
    
### 优化2 范围小时用插入排序 ###
    快速排序是通过递归实现的。随着递归层层深入，大量数据被分割成了小数组。
    快排对于大数组的划分可以迅速地将元素移动到它正确位置的附近，比如说对1024进行一次均等划分，那么某个元素可能会移动数百个单位位置。
    然而对于小数组，如16个元素的数组，快速排序也要划分4次才能把它移动到正确的位置上。
    相对于之前几百个位置的移动，小数组排序一次只能移动几个单位的位置。
    总之，当排序进入到小数组阶段后，它将多次因为这些小数组而频繁调用自身，但获得的收益并不大，称为"小数组的边际效应"。
    
    消除边际效应的一个方法是：
    设定一个M值，当数组元素个数小于M时，视为小数组，此时采用插入排序（插入排序对于基本有序数据的效率非常高）
    阈值设定在5~25之间时效果比较好，我们设定阈值为7。
    
    由于我们是将递归部分和划分处理部分作为两个函数，所以在递归部分进行如下处理：
```c
void quicksort_3(int * ar, int l, int r){
	if (l < r){
		if (r - l + 1 < 7){
			insert_sort(ar, l, r);
			return;
		}
		int result = quicksort_ee(ar, l, r);
		quicksort_3(ar, l, result - 1);
		quicksort_3(ar, result + 1, r);
	}
}
```
    
### 优化3 改进的三数取中法选基准 ###
    相对于随机选取基准，三元取中法（在数组的左，中，右抽样，并使用他们的中值作为划分元素）
    可以使得划分元素尽量接近序列的中间值，得到更高的效率优化。
    三数取中法对于对小数组来说有很大的概率选择到一个比较好的基准，但是对于大数组来说就不足以保证能够选择出一个好的基准，
    因此还有个办法是所谓九数取中，它是先从数组中分三次取样，每次取三个数，三个样品各取出中数，
    然后从这三个中数当中再取出一个中数作为基准，取样是分布在左端点、中点和右端点取样。
    三数取中的函数如下：
```c
int median(int * ar, int a, int b, int c){
	return ar[a] < ar[b] ? (ar[b] < ar[c] ? b : ar[a] < ar[c] ? c : a) 
		: ar[b] > ar[c] ? b : ar[a] > ar[c] ? c : a;
}
```
    什么时候采取这种方法,也有个数组大小的阈值，根据经验设定为40。
    >40的数组使用九数取中选择，>7且<40的数组使用三数取中选择中数，=7 的数组直接选择中数
```c
int len = r - l + 1;
int m = l + (len >> 1);       //取中数
int a, c, s;

if (len > 7){
	a = l;
	c = l + len - 1;
	if (len > 40){
		s = len / 8;
		a = median(ar, l, l + s, l + 2 * s);
		m = median(ar, m - s, m, m + s);
		c = median(ar, c - 2 * s, c - s, c);
	}
	m = median(ar, a, m, c);
}
swap(&ar[l], &ar[m]);
```

### 优化4 三路划分算法 ###
    在用十万重复数据测试时发现，前四种快速排序都出现了系统栈溢出错误，
    可见重复数据对快速排序递归的无用调用必须予以妥善处理。
    这个问题与荷兰旗问题十分类似，采取三路划分算法：
    仍然进行双向扫描，将相等元素交换到序列两端，当处理完所有元素之后才将两边等于基准的元素拷贝到序列中间，
    最后再分别递归处理其左边的序列和右边的序列；
    此时我们将递归部分和划分部分合并为一个函数以便于实现算法(基准的选取使用优化3的办法)。

### 运行时间对比 ###
* 十万随机数情况下

| quicksort_1 | quciksort_2 | quicksort_3 | quicksort_4 | quicksort_eeee |
| :----------: | :----------: | :----------: | :----------: | :----------: | 
| 0.042000 | 0.065000 | 0.047000 | 0.044000 | 0.029000 |

* 十万完全逆序数情况下

| quicksort_1 | quciksort_2 | quicksort_3 | quicksort_4 | quicksort_eeee |
| :----------: | :----------: | :----------: | :----------: | :----------: | 
| overflow | 0.044000 | 0.023000 | 0.012000 | 0.014000 |

* 十万完全正序数情况下

| quicksort_1 | quciksort_2 | quicksort_3 | quicksort_4 | quicksort_eeee |
| :----------: | :----------: | :----------: | :----------: | :----------: | 
| overflow | 0.050000 | 0.020000 | 0.008000 | 0.010000 |

* 十万完全重复数情况下，四种快速排序的时间分别为：
    
| quicksort_1 | quciksort_2 | quicksort_3 | quicksort_4 | quicksort_eeee |
| :----------: | :----------: | :----------: | :----------: | :----------: | 
| overflow | overflow | overflow | overflow | 0.007000 |
    
    分析可见，
    随着层层优化深入，效率得到一步步提高，同时对于某些特殊类型数据的处理也得以突破。
    十万随机数情况下，随机选取基准的方法不如第一种快排主要是因为随机数产生器带来的消耗，但它在其它几种数据情况下体现出来明显的优化；
    十万完全重复数据的情况下，前四种快排都出现了系统栈溢出，
    而三路划分快速排序专门针对重复数据的排序而设计，同时由于完全重复数据的特殊性，此时排序效率非常高；
    改进的三数取中法消除了随机产生器带来的开销，取中数的时间复杂度在O(1)，效率也大幅提高；
    小范围数据采取插入排序带来的效率提升最为明显。
    
## 线性排序 ##

### 计数排序 ###
    
    
    
    
### 桶排序 ###
### 基数排序 ###
### 运行时间对比 ###



## 参考文献 ##
[怎样让快速排序更快](http://blog.sina.com.cn/s/blog_4dff8712010136jh.html)

[快速排序及优化] (http://www.blogjava.net/killme2008/archive/2015/12/29/331404.html)

[经典算法系（18）-快速排序实现之三路划分, 三元中值法和插入排序处理小子文件](https://www.douban.com/note/219642993/)

[三种线性排序算法 计数排序、桶排序与基数排序] (https://www.byvoid.com/blog/sort-radix)
