# 快速排序和线性排序 #
## 介绍 ##
	快速排序是一种划分交换排序，采用的是分治策略。一次排序将数据分割成两个部分，一部分比基准小，一部分比基准大。
	可见，其关键就是关于基准元素的选取以及划分算法的设计。
	快速排序是基于比较的排序，无法突破O(nlogn)的时间界限，但线性排序是不基于比较的排序，可以突破这一界限。
	不过线性排序的使用范围有很多限制，例如数据量的大小，排序数据的范围等。
	
	本文包括快速排序的四个优化和线性排序（计数排序、桶排序和基数排序）的实现。
	快速排序的一大特点就是效率不稳定，运行时间与输入的数据密切相关。
	因此，采用十万个随机数据，正序数据、逆序数据以及完全重复数据作为测试用例比较快速排序的几个优化和三种线性排序的效率。

## 快速排序的几个优化 ##
    快速排序的最初实现是选取左端点为基准，进行双向扫描。
    以下为四个针对不同方面进行的优化：
    1. 随机选取基准，仍然进行双向扫描
    2. 随机选取基准，仍然双向扫描，但当排序范围缩小到一定程度时，采取插入排序
    3. 改进的三数取中法选取基准，仍然双向扫描，当排序范围缩小到一定程度时，采取插入排序
    4. 改进的三数取中法选取基准，三路划分算法，当排序范围缩小到一定程度时，采取插入排序

### 优化1 随机选取基准 ###
    最理想的基准值能把数组分成相当的两部分。
    对于随机的输入数据，固定的选取数组最左端元素和其他选取方法是一样的，在平均情况下二者都会接近中间的位置。
    但当输入数据本身有序时，随机选取数组中某个位置上的元素而不总是选取最左端元素可以有效避免快排退化为O(n^2)。
    
    随机选取基准函数如下：
```c
int rand(int l, int r)
{
	srand((unsigned)time(NULL));
	int size = r - l + 1;
	return l + rand() % size;
}
```
    然后通过 "swap(&ar[l], &ar[m]);" 将选取的基准移到最左端，其余部分与最初实现一样。
    
### 优化2 范围小时用插入排序 ###
    快速排序是通过递归实现的。随着递归层层深入，大量数据被分割成了小数组。
    快排对于大数组的划分可以迅速地将元素移动到它正确位置的附近，比如说对1024进行一次均等划分，那么某个元素可能会移动数百个单位位置。
    然而对于小数组，如16个元素的数组，快速排序也要划分4次才能把它移动到正确的位置上。
    相对于之前几百个位置的移动，小数组排序一次只能移动几个单位的位置。
    总之，当排序进入到小数组阶段后，它将多次因为这些小数组而频繁调用自身，但获得的收益并不大，称为"小数组的边际效应"。
    
    消除边际效应的一个方法是：
    设定一个M值，当数组元素个数小于M时，视为小数组，此时采用插入排序（插入排序对于基本有序数据的效率非常高）
    我们设定阈值为7.
  
### 优化3 三数取中法选基准 ###

  
  
  
  
    
## 线性排序 ##
### 计数排序 ###

 

