# 快速排序和线性排序 #
## 介绍 ##
	快速排序是一种划分交换排序，采用的是分治策略。一次排序将数据分割成两个部分，一部分比基准小，一部分比基准大。
	可见，其关键就是关于基准元素的选取以及划分算法的设计。
	快速排序是基于比较的排序，无法突破O(nlogn)的时间界限，但线性排序是不基于比较的排序，可以突破这一界限。
	不过线性排序的使用范围有很多限制，例如数据量的大小，排序数据的范围等。
	
	本文包括快速排序的四个优化和线性排序（计数排序、桶排序和基数排序）的实现。
	快速排序的一大特点就是效率不稳定，运行时间与输入的数据密切相关。
	因此，采用十万个随机数据，正序数据、逆序数据以及完全重复数据作为测试用例比较快速排序的几个优化和三种线性排序的效率。

## 快速排序的几个优化 ##
    快速排序的最初实现是选取左端点为基准，进行双向扫描(quicksort_1)。
    以下为四个针对不同方面进行的优化：
    1. (quicksort_2)随机选取基准，仍然进行双向扫描
    2. (quicksort_3)随机选取基准，仍然双向扫描，但当排序范围缩小到一定程度时，采取插入排序
    3. (quicksort_4)改进的三数取中法选取基准，仍然双向扫描，当排序范围缩小到一定程度时，采取插入排序
    4. (quicksort_eeee)改进的三数取中法选取基准，三路划分算法，当排序范围缩小到一定程度时，采取插入排序

### 优化1 随机选取基准 ###
    最理想的基准值能把数组分成相当的两部分。
    对于随机的输入数据，固定的选取数组最左端元素和其他选取方法是一样的，在平均情况下二者都会接近中间的位置。
    但当输入数据本身有序时，随机选取数组中某个位置上的元素而不总是选取最左端元素可以有效避免快排退化为O(n^2)。
    
    随机选取基准函数如下：
```c
int rand(int l, int r){
	srand((unsigned)time(NULL));
	int size = r - l + 1;
	return l + rand() % size;
}
```
    然后通过 "swap(&ar[l], &ar[m]);" 将选取的基准移到最左端，其余部分与最初实现一样。
    
### 优化2 范围小时用插入排序 ###
    快速排序是通过递归实现的。随着递归层层深入，大量数据被分割成了小数组。
    快排对于大数组的划分可以迅速地将元素移动到它正确位置的附近，比如说对1024进行一次均等划分，那么某个元素可能会移动数百个单位位置。
    然而对于小数组，如16个元素的数组，快速排序也要划分4次才能把它移动到正确的位置上。
    相对于之前几百个位置的移动，小数组排序一次只能移动几个单位的位置。
    总之，当排序进入到小数组阶段后，它将多次因为这些小数组而频繁调用自身，但获得的收益并不大，称为"小数组的边际效应"。
    
    消除边际效应的一个方法是：
    设定一个M值，当数组元素个数小于M时，视为小数组，此时采用插入排序（插入排序对于基本有序数据的效率非常高）
    阈值设定在5~25之间时效果比较好，我们设定阈值为7。
    
    由于我们是将递归部分和划分处理部分作为两个函数，所以在递归部分进行如下处理：
```c
void quicksort_3(int * ar, int l, int r){
	if (l < r){
		if (r - l + 1 < 7){
			insert_sort(ar, l, r);
			return;
		}
		int result = quicksort_ee(ar, l, r);
		quicksort_3(ar, l, result - 1);
		quicksort_3(ar, result + 1, r);
	}
}
```
    
### 优化3 改进的三数取中法选基准 ###
    相对于随机选取基准，三元取中法（在数组的左，中，右抽样，并使用他们的中值作为划分元素）
    可以使得划分元素尽量接近序列的中间值，得到更高的效率优化。
    三数取中法对于对小数组来说有很大的概率选择到一个比较好的基准，但是对于大数组来说就不足以保证能够选择出一个好的基准，
    因此还有个办法是所谓九数取中，它是先从数组中分三次取样，每次取三个数，三个样品各取出中数，
    然后从这三个中数当中再取出一个中数作为基准，取样是分布在左端点、中点和右端点取样。
    三数取中的函数如下：
```c
int median(int * ar, int a, int b, int c){
	return ar[a] < ar[b] ? (ar[b] < ar[c] ? b : ar[a] < ar[c] ? c : a) 
		: ar[b] > ar[c] ? b : ar[a] > ar[c] ? c : a;
}
```
    什么时候采取这种方法,也有个数组大小的阈值，根据经验设定为40。
    >40的数组使用九数取中选择，>7且<40的数组使用三数取中选择中数，=7 的数组直接选择中数
```c
int len = r - l + 1;
int m = l + (len >> 1);       //取中数
int a, c, s;

if (len > 7){
	a = l;
	c = l + len - 1;
	if (len > 40){
		s = len / 8;
		a = median(ar, l, l + s, l + 2 * s);
		m = median(ar, m - s, m, m + s);
		c = median(ar, c - 2 * s, c - s, c);
	}
	m = median(ar, a, m, c);
}
swap(&ar[l], &ar[m]);
```

### 优化4 三路划分算法 ###
    在用十万重复数据测试时发现，前四种快速排序都出现了系统栈溢出错误，
    可见重复数据对快速排序递归的无用调用必须予以妥善处理。
    这个问题与荷兰旗问题十分类似，采取三路划分算法：
    仍然进行双向扫描，将相等元素交换到序列两端，当处理完所有元素之后才将两边等于基准的元素拷贝到序列中间，
    最后再分别递归处理其左边的序列和右边的序列；
    此时我们将递归部分和划分部分合并为一个函数以便于实现算法(基准的选取使用优化3的办法)。

### 运行时间对比 ###
* 十万随机数情况下

| quicksort_1 | quciksort_2 | quicksort_3 | quicksort_4 | quicksort_eeee |
| :----------: | :----------: | :----------: | :----------: | :----------: | 
| 0.042000 | 0.065000 | 0.047000 | 0.044000 | 0.029000 |

* 十万完全逆序数情况下

| quicksort_1 | quciksort_2 | quicksort_3 | quicksort_4 | quicksort_eeee |
| :----------: | :----------: | :----------: | :----------: | :----------: | 
| overflow | 0.044000 | 0.023000 | 0.012000 | 0.014000 |

* 十万完全正序数情况下

| quicksort_1 | quciksort_2 | quicksort_3 | quicksort_4 | quicksort_eeee |
| :----------: | :----------: | :----------: | :----------: | :----------: | 
| overflow | 0.050000 | 0.020000 | 0.008000 | 0.010000 |

* 十万完全重复数情况下
    
| quicksort_1 | quciksort_2 | quicksort_3 | quicksort_4 | quicksort_eeee |
| :----------: | :----------: | :----------: | :----------: | :----------: | 
| overflow | overflow | overflow | overflow | 0.007000 |
    
    分析可见，
    随着层层优化深入，效率得到一步步提高，同时对于某些特殊类型数据的处理也得以突破。
    十万随机数情况下，随机选取基准的方法不如第一种快排主要是因为随机数产生器带来的消耗，但它在其它几种数据情况下体现出来明显的优化；
    十万完全重复数据的情况下，前四种快排都出现了系统栈溢出，
    而三路划分快速排序专门针对重复数据的排序而设计，同时由于完全重复数据的特殊性，此时排序效率非常高；
    改进的三数取中法消除了随机产生器带来的开销，取中数的时间复杂度在O(1)，效率也大幅提高；
    小范围数据采取插入排序带来的效率提升最为明显。
    
## 线性排序 ##
   线性排序必须有数据范围 K 和数据量 N 作为已知，显然当待排序数据类型为int时一定有 K >= N
   
### 计数排序 ###
    计数排序是通过一遍扫描序列统计每个数据出现的次数来排序。
    br[i]表示待排序数据中i的个数，再对br从头累加，br[i] = br[i] + br[i-1]，最后所得br[i]就表示待排序数据中不大于i的数据个数。
    然后再利用br[i]就可以得出待排序数据中每个数据正在排好序的序列中的相对位置，如下：
```c
for (i = maxsize - 1; i >= 0; i--)
	cr[--br[ar[i]]] = ar[i];    
```
    以上逆序处理是为了保证计数排序的稳定性。
    分析可得计数排序的时间复杂度为O(N+K)，空间复杂度为O(N+K)，其中N为待排序数据的数量，K为待排序数据的范围。
    
### 桶排序 ###
    计数排序实际上是桶排序的一种特殊情况。
    对于计数排序而言，如果排序数据量非常大，无法一次开出那么大的空间，这时候就可以用桶来处理。
    桶的数据结构如下：
```c
struct node{
	keytype key;
	struct node * next;
};
typedef struct node * keynode;
```
    假设我们有 bucket_num 个桶，第 i 个桶 bucket_table[i] 存储 i * K / bucket_num 至 (i+1) *  K / bucket_num 之间的数，
    因此每个数据的位置 Index = ar[i] / (K / bucket_num)。
    当 bucket_num 接近于 N 时，桶排序的时间复杂度就可以近似认为是 O(N)，但是桶越多空间开销也越大。
    
    另外要注意的是，桶中元素的顺序放入和顺序取出是有必要的，这样才能保证桶排序也是稳定的。
    基本思路如下：
    
    1. 扫描序列，根据每个元素的值所属的区间，将数据放入桶中（即单链表插入）此过程控制有序插入；
    2. 依次收集每个桶中的元素，顺序放置到输出序列中。
    
    显见的是，可以用快速排序或其他排序来优化这一过程，我采取的优化是：
    将数据放入桶的过程无须控制有序，只要保证顺序放入即可；
    然后依次收集每个桶中的数据，每次收集完成后对数据进行一次快排。
    由于随着桶号小的数据小于桶号大的数据，所以桶间也是有序的。
    
    优化后的代码如下：
 ```c
 for (j = bucket_num - 1; j >= 0; j--){
	keynode q = bucket_table[j];
	int tmp = i;
	while (q){
		ar[i] = q->key;
		i--;
		q = q->next;
	}
	quicksort_eeee(ar, i + 1, tmp);
	free(bucket_table[j]);
}
 ```

### 基数排序 ###
    基数排序适用于多个关键字的排序。
    从最低有效关键字开始排序，称为LSD(Least Significant Dight)排序。
    首先对所有的数据按照次要关键字排序，然后对所有的数据按照首要关键字排序。
    要注意的是，要求排序算法一定是稳定的，否则就会取消前一次排序的结果。
    
    对于一个位数有限的十进制数，可以将每一位看作多元组中的一个元素，个位关键字重要度最低，其余依次增强。
    对于数据进行figure次排序之后，即可得到有序序列。其中figure为十进制数的位数。
    于是可以这样划分：
```c
int radix(int k, int p){
	int po1, po2;
	po1 = pow(10, p);
	po2 = pow(10, p - 1);
	return ((k % po1) / po2);
}
```
    采用队列来实现基数排序，设置十个队列，队列就相当于桶的作用。
    队列比单链表好的原因是它的插入和弹出对于数据的相对位置有非常好的保护作用，维护起来比单链表要简单。
```c
struct _queue{
	int front, rear;
	int elements[maxsize];
};
typedef struct _queue * queue;
```

### 运行时间对比 ###
    数据范围是 K = 100000，桶数取 10000。
* 十万随机数情况下

| counting_sort | bucket_sort | bucket_sort2 | radix_sort | 
| :----------: | :----------: | :----------: | :----------: | 
| 0.002000 | 0.073000 | 0.051000 | 0.083000 | 

* 十万完全逆序数情况下

| counting_sort | bucket_sort | bucket_sort2 | radix_sort | 
| :----------: | :----------: | :----------: | :----------: | 
| 0.002000 | 0.025000 | 0.036000 | 0.085000 | 

* 十万完全正序数情况下

| counting_sort | bucket_sort | bucket_sort2 | radix_sort | 
| :----------: | :----------: | :----------: | :----------: | 
| 0.001000 | 0.032000 | 0.034000 | 0.079000 | 

* 十万完全重复数情况下
    
| counting_sort | bucket_sort | bucket_sort2 | radix_sort | 
| :----------: | :----------: | :----------: | :----------: | 
| 0.002000 | 83.264000 | 0.033000 | 0.088000 | 

	分析可见，
   	无论哪种情况，计数排序的效率都非常高，因为它纯粹依靠统计规律来实现排序。
   	无论哪种情况，基数排序效率也都差不多，因为基数排序的效率很大程度上取决于数据的位数，
   	如排序十万个两位重复整数的效率几乎是排序十万个五位重复整数效率的3倍。
   	
   	在十万完全重复数据的情况下，对于桶排序来说，对其进行快排优化效果表现十分明显，优化后的效率约为优化前的3000倍。
   	在十万完全逆序数据情况下，优化后反而不如优化前，这是因为快排的反复调用和多次比较，
   	然而完全逆序数据在单链表插入过程中的只需一次比较再头插即可，所以效率要高很多，
   	而且显然要高于完全正序数据的情况，因为完全正序数据在单链表的插入过程中需要多次比较才能确定插入位置。
   
  
## 参考文献 ##
[怎样让快速排序更快](http://blog.sina.com.cn/s/blog_4dff8712010136jh.html)

[快速排序及优化] (http://www.blogjava.net/killme2008/archive/2015/12/29/331404.html)

[经典算法系（18）-快速排序实现之三路划分, 三元中值法和插入排序处理小子文件](https://www.douban.com/note/219642993/)

[三种线性排序算法 计数排序、桶排序与基数排序] (https://www.byvoid.com/blog/sort-radix)
