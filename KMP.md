# KMP算法 #
## 介绍 ##

        字符串匹配问题——在一个主文本字符串 S 内查找一个词 W 的出现位置。

>
    引自维基百科
>
    在计算机科学中，Knuth-Morris-Pratt字符串查找算法（常简称为“KMP算法”）可在一个主文本字符串S内查找一个词W的出现位置。
>
    此算法通过运用对“这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始”的发现，
>
    从而避免重新检查先前匹配的字符。
    
    
## 算法介绍 ##
        给定一个主文本字符串 （称为模式串）S, 一个匹配串 P。
        解决字符串匹配问题，按如下过程进行讨论：
        
### 暴力搜索算法 ###
        最普通的算法就是暴力搜素算法，即将主文本字符串 S 和匹配串 P 最左端对齐，依次开始比较，
        一旦比较失败，就让 P 的头对齐 S 的下一位，再从 P 的头开始依次比较。
        重复这一过程，直到匹配成功或者 P 已经移到了 len(S) - len(P) 的位置。
    
        可见这种算法的最坏情况下要比较 len(P) * (len(S) - len(P) + 1) 次。
        设 len(S) = n， len(P) = m，那么该算法的时间复杂度就是 O(m * n)。
        显然，这些次数里面有很多次比较是无意义的。
    
        要提高算法的效率，就要避免这些无意义的比较还有机械式的移动和回溯，
        所以要考虑利用我们从当前已经做过的尝试获得的那些信息来使下一步的比较尝试更有目的性。
        我觉得这个想法和动态规划算法的思想很像。
    
    
### KMP算法 ###

        根据Matrix67 的博客，可以有如下理解：
                
        假设当前匹配成功的部分为 S[i-j+1,i] = P[1,j]，
        也就是说，i 是不断增加的，随着 i 的增加 j 相应地变化，且j满足以 S[i] 结尾的长度为 j 的字符串正好匹配 
        S 串的前个字符（j 当然越大越好）。
                
        现在需要检验 S[i+1] 和 P[j+1] 的关系：
                
        当A[i+1]=B[j+1]时，i和j各加一；
        什么时候j=m了，我们就说B是A的子串（B串已经整完了），并且可以根据这时的i值算出匹配的位置。
        当 S[i+1] <> P[j+1]，KMP的策略是调整 j 的位置（减小 j 值）使得 S[i-j+1..i] 与 P[1..j] 保持匹配
        且新的 S[j+1] 恰好与 P[i+1] 匹配（从而使得 i 和 j 能继续增加）
                
        如何调整 j 的位置，即如何选择一个新的 j'，使 S[i-j'+1,i] = P[1,j']。
                
>       j' 必须要使得 P[1..j] 中的头 j' 个字母和末 j' 个字母完全相等（这样 j 变成了 j' 后才能继续保持 i 和 j 的性质）
        
        可以这样理解，随意选择一个 j'，因为 S[i-j+1,i] = P[1,j] 且 j' < j， 
        可见 S[i-j'+1] 和 P[1,j] 中的末 j' 个字母是匹配的。
        所以，如果 P[1..j] 中的头 j' 个字母和末 j' 个字母完全相等，那么 S[i-j'+1] 和 P[1,j']也是匹配的。
        即，S[i-j'+1,i] = P[1,j']。同时，这个 j' 当然要越大越好。
        
        以上的过程很好地体现了利用已经做过的尝试来指导下一步尝试的思想。
        
        在上述的 j 和 j' 之间建立一个对应的关系，设 j' = next[j]。

        于是求 next 数组就成了实现 KMP 算法的关键所在。
        
* **求 next 数组**

        求 next 数组是只针对匹配串进行的预处理，其实就是匹配串进行自我匹配的过程，同时它也是一个递归的过程。
        
  ```c
  while (j < len - 1){
        if (k == -1 || st[k] == st[j]){
        	k++;
        	j++;
        	if (st[j] != st[k])
        	        next[j] = k;
        	//因为 P[j] 是匹配失败的， 如果出现 p[j] = p[next[j]] 即 p[j] = p[j']，
        	//那么下一步 P[j'] 也会匹配失败，显然是不符合我们对 j' 的要求的。
        	//所以当出现时需要继续递归，k = next[k] = next[next[k]]...
        	else
        		next[j] = next[k];
        }
        else
            k = next[k];
  }
  ```
                
## 复杂度分析 ##

        KMP 算法的时间复杂度是线性的O(N)，N 为模式串的长度。
>
     为什么这个程序是O(n)的？
     其实，主要的争议在于，while 循环使得执行次数出现了不确定因素。
     我们将用到时间复杂度的摊还分析中的主要策略，
     简单地说就是通过观察某一个变量或函数值的变化来对零散的、杂乱的、不规则的执行次数进行累计。
     KMP的时间复杂度分析可谓摊还分析的典型。
>
     我们从上述程序的j 值入手：
     j 只会执行两个操作，第一个是每一次执行 while 循环都会使j减小（但不能减成负的）；
     第二个是 j++，整个过程中 j 最多加了 n 个1。
     于是，j 最多只有 n 次减小的机会（j 值减小的次数当然不能超过 n ，因为 j 永远是非负整数）。
     这告诉我们，while 循环总共最多执行了 n 次。
     按照摊还分析的说法，平摊到每次 for 循环中后，一次 for 循环的复杂度为 O(1)。
     整个过程显然是 O(n) 的。
        
        
## 扩展 ##
        一个类似的字符串匹配问题——判断小字符串中的字符在大字符串中是否全部存在
        
## 参考文献 ##
[CSDN博客“从头到尾彻底理解KMP”](http://blog.csdn.net/v_july_v/article/details/7041827)

[KMP算法详解|Matrix67](http://www.matrix67.com/blog/archives/115)

[判断小字符串中字母在大字符串中是否全部存在](http://blog.csdn.net/u010387196/article/details/19343227)

    
   
