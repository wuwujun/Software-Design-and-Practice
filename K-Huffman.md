# K叉哈夫曼树 #

## 介绍 ##
    
>
    引自维基百科
    霍夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。
    所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。
    树的路径长度是从树根到每一结点的路径长度之和，记为WPL=（W1*L1+W2*L2+W3*L3+...+Wn*Ln),N个权值Wi（i=1,2,...n）构成一棵有N个叶结点的二叉树，
    相应的叶结点的路径长度为Li（i=1,2,...n）。可以证明霍夫曼树的WPL是最小的。
    
    程序可实现用户输入 K 值，构造 K叉哈夫曼树，打印哈夫曼编码表，用于构造哈夫曼树的文本已经存储在txt文件里。
    
    
## 对比 ##
    1. 二叉哈夫曼树的构造方法是：
>   
    [引自百度百科]
    假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：
    (1) 将w1、w2、…、wn，看成是有 n 棵树的森林(每棵树仅有一个结点)；
    (2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
    (3) 从森林中删除选取的两棵树，并将新树加入森林；
    (4) 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。
    
    2. 如何获得哈夫曼编码：
    叶节点存储符号，从根到叶，左编0，右编1。
    哈夫曼编码不等长，具有前缀性。
    
    3. K叉哈夫曼树的构造方法：
    对比二叉哈夫曼树的构造方法，实际上K叉哈夫曼的构造过程十分类似，将二叉树变成K叉树即可。
    虽然基本思想很类似，但是实现起来还是有很多细节和方法的不同。

## 数据结构 ##
* **数值宏变量**
```c
#define NODENUM 511       //ASCII里的字符总数为256
```

* **字符结点的存储结构**
```c
struct ele{
	int value;
	int count;
};
typedef struct ele element;
```

* **哈夫曼树的存储结构**

由树的孩子兄弟表示法及线索二叉树存储结构中标志域的启发，采用如下存储结构：  

```c
struct treenode{
	int weight;
	struct treenode * lchild;
	struct treenode * rightsib;
	int tag;
};
typedef struct treenode * htree;
```

## 算法介绍 ##
    【1】统计txt文本中各个字符出现的频率；
    【2】排除空格和不可打印字符，每个字符创建对应的结点，构成一个字符结点数组，然后用快速排序对其排序；
    【3】构造K叉哈夫曼树，这一步里有几个要点：
        【3.1】设有 N 个字符，在文本出现的次数分别是W1，W2，W3，…，Wn，将它们设为权值。
               k0=（n-1）mod（k-1），因为哈夫曼树是扩充二叉树，所以每个顶点的度不是0就是k，
               当k0=0时，即（n-1）/（k-1）为整数，哈夫曼树中只有度为0和k的结点；
               当k0≠0时，即（n-1）/（k-1）不为整数时，需添加k-1-k0个权值为0的结点才能使其满足性质。
               注意添加结点之后要更新叶子结点的数目leaf。
        【3.2】根据字符节点数组来初始化 leaf 个 treenode，并且利用它们的 rightsib 指针将这些结点串成单链表 L（单链表是升序的）；
        【3.3】以 K 为步长，取单链表 L 的 K 个结点,第 i 个结点的 tag = k - i - 1（i 从0开始）。
               合并得一个新结点再插入到单链表 L 中，和二叉哈夫曼树处理是一样的。
               但是在这一步中，要注意的是，要利用叶子节点的 rightsib 域将所有叶子串成一个单链表 L'。
               这样是方便以后求编码时，沿着 L' 的 rightsib 域可以迅速找到字符所在的叶子结点，然后再对叶子结点求编码。
               
               
## 不足 ##
    根据以上描述，链表的有序插入是比较麻烦的，由这点出发考虑优化，可以尝试用堆实现？


## 扩展1 ##
    本程序没有完成数据的解压缩过程，实际上可以根据获得的哈夫曼编码表转换回符号。参考维基百科。
>
    简单来说，霍夫曼码树的解压缩就是将得到的前置码（Prefix Huffman code）转换回符号，通常借由树的追踪（Traversal），将接收到的比特串（Bits stream）一步一步还原。
    但是要追踪树之前，必须要先重建霍夫曼树 ；某些情况下，如果每个符号的权重可以被事先预测，那么霍夫曼树就可以预先重建，并且存储并重复使用，否则，发送端必须预先发送霍夫曼树的相关信息给接收端。
>
    最简单的方式，就是预先统计各符号的权重并加入至压缩之比特串，但是此法的运算量花费相当大，并不适合实际的应用。
    若是使用Canonical encoding，则可精准得知树重建的数据量只占B2^B比特（其中B为每个符号的比特数（bits））。
    如果简单将接收到的比特串一个比特一个比特的重建，例如：'0'表示父节点，'1'表示终端节点，若每次读取到1时，下8个比特则会被解读是终端节点（假设数据为8-bit字母），则霍夫曼树则可被重建，以此方法，数据量的大小可能为2~320字节不等。
    虽然还有很多方法可以重建霍夫曼树，但因为压缩的数据串包含"traling bits"，所以还原时一定要考虑何时停止，不要还原到错误的值，如在数据压缩时时加上每笔数据的长度等。


## 扩展2 ##
    动态哈夫曼，参考百度百科。
>
    哈夫曼动态编码：动态哈夫曼编码使用一棵动态变化的哈夫曼树，对第t+1个字符的编码是根据原始数据中前t个字符得到的哈夫曼树来进行的，
    编码和解码使用相同的初始哈夫曼树，每处理完一个字符，编码和解码使用相同的方法修改哈夫曼树，所以没有必要为解码而保存哈夫曼树的信息。
    编码和解码一个字符所需的时间与该字符的编码长度成正比，所以动态哈夫曼编码可实时进行。
    
## 参考文献 ##

[C语言在K叉哈夫曼编码教学中的应用](http://blog.sina.com.cn/s/blog_a4c08ba00101nfnk.html)
