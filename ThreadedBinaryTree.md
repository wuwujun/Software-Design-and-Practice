# 线索二叉树 #

## 介绍 ##

    二叉树的线索化:对二叉树以某种次序遍历使其变为线索二叉树的过程。
    简单来讲就是如果空指针域为左指针域,则指向该结点的前驱,即它的双亲；如果空指针域为右指针域,则指向该结点的后继。
    
    程序输入为文件，二叉树的信息都存储在txt文件中。

## 数据结构 ##

```c
thtree pre;    //刚刚访问过的结点
struct node{
	struct node * lchild;
	struct node * rchild;
	int ltag;  //=1 表示为结点的前驱
	int rtag;   //=1 表示为结点的后继
	datatype data;
};
typedef struct node * thtree;
```

## 算法介绍 ##
* **前序线索化**

        实际上就是在前序遍历过程中进行处理，有两个要点：
        1. 注意在每一次递归中只处理当前结点 p 的左儿子和刚刚访问过的结点 pre 的右儿子，
           因为 pre 是 p 的前驱， p 是 pre 的后继。
        2. 是否递归要加上判断条件 if (p->ltag == 0) 和 if (p->rtag == 0)，
           因为如果左儿子或右儿子指向的是前驱或者后继的话，会出现死循环。

* **后序线索化**

        和前序线索化是一样的，只不过是在后序遍历的过程中进行处理。
        还有要注意的是，这里的遍历不需要加上如上的判断条件，
        因为后序遍历是某结点的左右子树均遍历完之后才访问该结点进行线索化处理的。

* **二叉树线索化的主函数**

        二叉树进行线索化需要添加一个头结点，头结点的左指针指向树根，
        但是对于右指针的处理，前序或后序线索化不一样：
    ```c
    if (key == 1)
    	pre_thread_tree(t);
    else if (key == 2)
    	post_thread_tree(t);
    		
    if (key == 1){
    		pre->rchild = *head;
    		pre->rtag = 1;
    		(*head)->rchild = pre;
    }
    else if (key == 2)
    	(*head)->rchild = pre;
    ```

## 不足 ##
        未能完成前序线索树利用前序线索进行的中序遍历和后序线索树利用后序线索进行的中序遍历
        
## 参考文献 ##

[中序线索化的线索二叉树的前序遍历、中序遍历和后序遍历](http://4802380.blog.51cto.com/4792380/1156314)


