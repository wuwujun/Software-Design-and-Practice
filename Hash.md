# 散列查找 #

## 介绍 ##

  散列查找是不基于关键字比较的查找，它通过在关键字和存储位置之间建立一个映射关系来进行查找。
  
  此处的映射称为`哈希函数`，函数值为关键字对应的散列地址。
  
  本文采用的哈希函数构造算法是`字符串的time33算法`和 `除数取余法`。
  
  存储关键字的数组称为`哈希表`，数组的每个单元叫做`桶`。
  
  将结点（记录）按其关键字的散列地址存储到散列表中的过程称为`散列`。
  
  在进行散列过程中，可能会出现不同关键字对应同一散列地址的情况，称为`散列冲突`，本文将通过`拉链法`来解决冲突问题。
    

## 数据结构 ##
    如下设计，哈希表就相当于很多个并联的单链表，有点类似于图的邻接表存储结构
```c
struct _bucket{
	keytype * key;
	valuetype value;             
	struct _bucket * next;
};
typedef struct _bucket * bucket;

struct _hashtable{
	unsigned long size;						//hashtable的实际大小 
	unsigned long ele_num;				//已经插入的元素数目
	bucket * buckets;			            	
};
typedef _hashtable hashtable;
```

## 哈希函数的构造算法 ##
    输入的数据为字符串，选择time33算法来进行处理
```c
unsigned long Hash_str(hashtable * ht, keytype * key, int len){
	unsigned long hash = 5381;
	int i;
	
	for (i = 0; i < len; i++){
		hash = (hash << 5) + hash + (unsigned long) *(key + i);
	}
	return (hash & 0x7FFFFFFF) % ht->size;
}
```

## 哈希表的几个基本操作 ##
    实现基本操作之后要销毁哈希表，防止内存泄漏。
### 插入 ###
    哈希表的插入实际上与单链表的插入一样，只不过需要注意三点：
    
    【1】 在进行插入操作之前要考虑哈希表是否已经填满了，一旦填满，就需要进行扩容，一般情况下扩充为原来的两倍；
        即：重新申请两倍空间之后，再将之前哈希表中的数据copy到新的哈希表中，再进行插入操作；
    【2】 插入过程中要判断关键字是否已经存在，若存在且关键字的value值和新插入关键字的value值不同，则更新value；
    【3】 出现冲突则将关键字用头插法插到单链表中，单链表头指针指向新插入的关键字。
    
### 删除 ###
    哈希表的删除就是单链表的删除，首先判断关键字是否存在。
    
### 查找 ###
    哈希表的查找分为两步：
    
    【1】 通过哈希函数得出散列地址；
    【2】 散列地址对应位置为空则查找失败，否则在散列地址对应的存储位置的单链表上进行比较查找。


## 测试 ##
    测试采用163008个随机生成的IP地址形成哈希表，再查找1万个随机生成的IP地址，多次重复实验：
    
>
    装载因子为1.630080，约耗时 0.002000 ~ 0.009000 ms；
    装载因子为0.815040，约耗时 0.001000 ~ 0.005000 ms；
    
    分析可知：
    在查找过程中，关键码的比较次数取决于产生冲突的概率。
    而影响冲突产生的因素有：
    1. 散列函数是否均匀；
    2. 处理冲突的方法；
    3. 散列表的装载因子 α = 表中填入的记录数 / 表的长度。
    
    哈希表查找的效率与以上几个因素密切相关。
    
    采用字符串的time33算法，所得冲突数量约为数据总量的一半，装载因子又在1附近，可见数据分布还是比较均匀的。
    所以测试得出的查找效率是非常高的。
    
    


